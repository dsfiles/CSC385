ex01_variable_scope.c�������������������������������������������������������������������������������0000644�0003721�0003721�00000001206�14331532453�013555� 0����������������������������������������������������������������������������������������������������ustar  �user����������������������������user�������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������#include <stdio.h>
#include <stdlib.h>

/* Global scope that is visible to all the functions */
int x = 3;

/* A function declaration tells the compiler about a function name and parameters */ 
void print_number(); // function declaration

int main()
{
        printf("x = %d\n", x); // global x
        int x = 5; // Local scope of 'main'
        {
                int x = 8; // Local scoope of '{ ... }'
                printf("x = %d\n", x);
        }
        printf("x = %d\n", x);
        print_number();
        exit(0);
}

/* a function that prints a number */
void print_number() // function definition
{
        printf("x = %d\n", x);
}
������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������ex02_swap_numbers_using_pointers.c������������������������������������������������������������������0000644�0003721�0003721�00000001274�14331534755�016451� 0����������������������������������������������������������������������������������������������������ustar  �user����������������������������user�������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������/* Swap two numbers using C pointers*/
#include <stdio.h>

// function to swap the two numbers
void swap(float *x, float *y)
{
    float t;
     t  = *x;
    *x  = *y;
    *y  =  t;
}

float main()
{
    float n1,n2;

    printf("Enter value of n1: ");
    scanf("%f",&n1); // scanf takes in a number and store it at the address of variable
    printf("Enter value of n2: ");
    scanf("%f",&n2);

    // numbers before swapping ('%.1f' specifier prints one decimal point float number)
    printf("Before swapping: n1: %.1f, n2: %.1f\n", n1, n2);

    // call the function
    swap(&n1, &n2);

    // numbers after swapping
    printf(" After swapping: n1: %.1f, n2: %.1f\n",n1, n2);

    return 0;
}������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������ex04_dining_philosopers.c���������������������������������������������������������������������������0000644�0003721�0003721�00000001721�14331543452�014504� 0����������������������������������������������������������������������������������������������������ustar  �user����������������������������user�������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������/* https://medium.com/swlh/the-dining-philosophers-problem-solution-in-c-90e2593f64e8 */
#include<stdio.h>
#include<stdlib.h>
#include<pthread.h>
#include<semaphore.h>
#include<unistd.h>

sem_t room;
sem_t chopstick[5];

void * philosopher(void *);
void eat(int);
int main()
{
	int i,a[5];
	pthread_t tid[5];
  
	sem_init(&room,0,4);
	
	for(i=0;i<5;i++)
		sem_init(&chopstick[i],0,1);
		
	for(i=0;i<5;i++){
		a[i]=i;
		pthread_create(&tid[i],NULL,philosopher,(void *)&a[i]);
	}
	for(i=0;i<5;i++)
		pthread_join(tid[i],NULL);
}

void * philosopher(void * num)
{
	int phil=*(int *)num;

	sem_wait(&room);
	printf("\nPhilosopher %d has entered room",phil);
	sem_wait(&chopstick[phil]);
	sem_wait(&chopstick[(phil+1)%5]);

	eat(phil);
	sleep(2);
	printf("\nPhilosopher %d has finished eating",phil);

	sem_post(&chopstick[(phil+1)%5]);
	sem_post(&chopstick[phil]);
	sem_post(&room);
}

void eat(int phil)
{
	printf("\nPhilosopher %d is eating",phil);
}
/* BY - ANUSHKA DESHPANDE */�����������������������������������������������ex05_dining_philosopers.c���������������������������������������������������������������������������0000644�0003721�0003721�00000004344�14331542477�014517� 0����������������������������������������������������������������������������������������������������ustar  �user����������������������������user�������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������/* https://rosettacode.org/wiki/Dining_philosophers */
# include <pthread.h>
# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>
# include <stdarg.h>

#define N 5
// define an array of 5 strings (names)
const char* names[N] = { "Aristotle", "Kant", "Spinoza", "Marx", "Russell" };
pthread_mutex_t forks[N];

#define M 5 /* think bubbles */
const char* topic[M] = { "Spaghetti!", "Life", "Universe", "Everything", "Bathroom" };

#define lock pthread_mutex_lock // C directive that defines pthread_mutex_lock as lock
#define unlock pthread_mutex_unlock
#define xy(x, y) printf("\033[%d;%dH", x, y)
#define clear_eol(x) print(x, 12, "\033[K")

void print(int y, int x, const char* fmt, ...)
{
	static pthread_mutex_t screen = PTHREAD_MUTEX_INITIALIZER;
	va_list ap;
	va_start(ap, fmt);

	lock (&screen) ;
	xy(y + 1, x), vprintf(fmt, ap);
	xy(N + 1, 1), fflush(stdout);
	unlock(&screen);
}

void eat(int id)
{
	int f[2], ration, i; /* forks */
	f[0] = f[1] = id;

	/* make some (but not all) philosophers leftie.
	   could have been f[!id] = (id + 1) %N; for example */
	f[id & 1] = (id + 1) % N;

	clear_eol(id);
	print(id, 12, "..oO (forks, need forks)");

	for (i = 0; i < 2; i++)
	{
		lock (forks + f[i]) ;
		if (!i) clear_eol(id);

		print(id, 12 + (f[i] != id) * 6, "fork%d", f[i]);
		/* delay 1 sec to clearly show the order of fork acquisition */
		sleep(1);
	}

	for (i = 0, ration = 3 + rand() % 8; i < ration; i++)
		print(id, 24 + i * 4, "nom"), sleep(1);

	/* done nomming, give up forks (order doesn't matter) */
	for (i = 0; i < 2; i++) unlock(forks + f[i]);
}

void think(int id)
{
	int i, t;
	char buf[64] = { 0 };

	do
	{
		clear_eol(id);
		sprintf(buf, "..oO (%s)", topic[t = rand() % M]);

		for (i = 0; buf[i]; i++)
		{
			print(id, i + 12, "%c", buf[i]);
			if (i < 5) usleep(200000);
		}
		usleep(500000 + rand() % 1000000);
	} while (t);
}

void* philosophize(void* a)
{
	int id = *(int*)a;
	print(id, 1, "%10s", names[id]);
	while (1) think(id), eat(id);
}

int main()
{
	int i, id[N];
	pthread_t tid[N];

	for (i = 0; i < N; i++)
		pthread_mutex_init(forks + (id[i] = i), 0);

	for (i = 0; i < N; i++)
		pthread_create(tid + i, 0, philosophize, id + i);

	/* wait forever: the threads don't actually stop */
	return pthread_join(tid[0], 0);
}

������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
